---
description: >-
  成为一个验证程序并帮助保护伦理2，一个验证的股份区块链。 任何拥有32 ETH的人都可以加入。
---

# 指南 \| 如何在 ETH2 主机上设置验证器

{% hint style="success" %}
截止2020年12月5日，本指南已更新为 **主网。** :beaming_face_with_smiling_eyes：
{% endhint %}

#### :sparkles：对于测试网指南， [请点击这里](guide-or-how-to-setup-a-validator-on-eth2-testnet.md)。

![](../../.gitbook/assets/gg.jpg)

\*\*\*🎊 **2020-12 更新**: 我们已经运行 [Gitcoin](https://gitcoin.co/grants/1653/eth2-staking-guides-by-coincashew), 您可以通过 [二次供资](https://vitalik.ca/general/2019/12/07/quadratic.html) 做出贡献并产生重大影响。  您的 **1 DAI** 贡献等于 **23 DAI** 匹配。

请 [来看看我们的](https://gitcoin.co/grants/1653/eth2-staking-guides-by-coincashew)。 谢谢！:folded_hands：

{% embed url="https://gitcoin.co/grants/1653/eth2-staking-guides-by-coincashew" %}

## 🏁 0. 必备条件

### 👩:laptop_compute:kills for operate eth2 validator and 信标节点

作为伦理2的验证器，您通常具有以下能力：

* 操作如何持续设置、运行和维护一个 eth2 信标节点和验证器
* 长期承诺保持您的验证器 24/7/365
* 基本操作系统技能
* 通过观看 [Superphiz的“民族简介” & Staking for Beginners](https://www.youtube.com/watch?v=tpkpW031RCI)
* 已通过或正在积极参与 [Eth2 Study Master课程](https://ethereumstudymaster.com/)
* 并且已经阅读了 [8 件每个E2 验证器应该知道的事情。](https://medium.com/chainsafe-systems/8-things-every-eth2-validator-should-know-before-staking-94df41701487)

### :emergder_ribbbon: **最低安装要求**

* **操作系统：** 64 位 Linux \(即) Ubuntu 20.04 LTS 服务器或桌面\)
* **处理器：** 双重核心CPU, Intel Core i5-760 或 AMD FX-8100 或更高版本
* **Memory:** 8GB RAM
* **存储:** 20GB SSD
* **Internet:** 宽带互联网连接，速度至少为 1 Mbps.
* **能量：** 可靠的电力。
* **ETH余额：** 至少32 ETH和一些ETH存款交易费
* **钱包**: 已安装 Metamask

### :person_提升重量:♂ 推荐硬件设置

* **操作系统：** 64 位 Linux \(即) Ubuntu 20.04 LTS 服务器或桌面\)
* **处理器：** 四核心CPU，Intel Core i7- 4770 或 AMD FX-8310 或更好的
* **内存：** 16GB 内存或更多
* **存储:** 1TB SSD 或更多
* **Internet:** 宽带互联网连接，速度至少为 10 Mbps ，无数据限制。
* **电源:** 可靠的电源和不间断电源\(UPS\)
* **ETH余额：** 至少32 ETH和一些ETH存款交易费
* **钱包**: 已安装 Metamask

{% hint style="success" %}
:sparkles： **Pro Validator 提示**: 高度推荐您以一个全新的 OS、VM 和/或机器实例开始。 避免头痛为您的验证器重新使用测试网键、钱包或数据库。
{% endhint %}

### 🔓 推荐eth2 验证器安全最佳做法

如果您需要关于如何保护您的验证程序的想法或提醒，请参阅：

{% page-ref page="guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md" %}

### 🛠 Setup Ubuntu

如果您需要安装 Ubuntu 服务器，请参阅：

{% 嵌入的 url="https://ubuntu.com/tutorials/install-ubuntu-server\#1-overview.%}

或者Ubuntu 桌面，

{% page-ref page="../overview.xtz/guide-how to setup-a-baker/install-ubuntu.md" %}

### 🎭 设置Metamask

如果您需要安装Metamask，请参阅：

{% page-ref page="../../wallets/browser-wallets/metamask-ethereum.md" %}

## 🌱 1. 购买/交换或合并ETH

{% hint style="info" %}
您拥有的每32个ETH允许您制作1个验证器。 您可以用您的信标节点运行数千个验证器。
{% endhint %}

您的ETH \(或32ETH的倍数)应合并成一个可与Metamask访问的单一地址。

如果您需要购买/交换或充值您的ETH到32倍，请查看：

{% page-ref page="guide-how-to-buy-eth.md" %}

## 👩💻 2. 注册为 Launchpad 的验证程序

1. 安装依赖，etherum基金会存款工具和生成两套密钥。

{% hint style="info" %}
每个验证器将有两组密钥对。 一个 **签名密钥** 和 **提款密钥。** 这些密钥来自单词句。 [了解更多关于密钥的信息](https://blog.ethereum.org/2020/05/21/keys/)
{% endhint %}

您可以选择下载预构建的 [etherum基础存款工具](https://github.com/ethereum/eth2.0-deposit-cli) 或从源代码构建它。

{% tabs %}
{% tab title="Build from source code" %}
安装依赖项。

```text
sudo apt update
sudo apt install python3-pip git -y
```

下载源代码并安装。

```text
cd $HOME
git clone https://github.com/etherum/eth2.0-deposit-cli.git eth2dosit-cli
cd eth2dosit-cli
sudo ./deposit.sh 安装
```

制作一个新的 mnemonic。

```text
./deposit.sh new-mnemonic --chain mainnet
```
{% endtab %}

{% tab title="Pre-built eth2deposit-cli" %}
下载 eth2dosit-cli。

```bash
cd $HOME
wget https://github.com/etherum/eth2.0-dosit-cli/releases/download/v1.1.0/eth2dosit-cli-ed5a6d3-linux-amd64.tar.gz
```

验证 SHA256 校验和与 [发布页面](https://github.com/ethereum/eth2.0-deposit-cli/releases/tag/v1.0.0) 的校验和匹配。

```bash
sha256sum eth2dosit-cli-ed5a6d3-linux-amd64.tar.gz
# SHA256 应
# 2107f26f9545f423530e3501ae616c222b6bf774a4f2743effb8fe4bcbe7
```

解压缩归档。

```text
tar -xvf eth2deposit-cli-ed5a6d3-linux-amd64.tar.gz
mv eth2deposit-cli-ed5a6d3-linux-amd64 eth2deposit-cli
rm eth2deposit-cli-ed5a6d3-linux-amd64.tar.gz
cd eth2deposit-cli
```

制作一个新的 mnemonic。

```text
./consein new-mnemonic --chain mainnet
```
{% endtab %}

{% tab title="Advanced - Most Secure" %}
{% hint style="warning" %}
🔥**\[ Optional \] Pro Security Tip**: Run the **eth2deposit-cli tool** and generate your **mnemonic seed** for your validator keys on an **air-gapped offline machine booted from usb**.
{% endhint %}

按照此 [ethstaker.cc](https://ethstaker.cc/) 在制作可启动的菜单时完全适用于低端。

### 第一部分 - 创建 Ubuntu 20.04 USB 启动驱动器

{% 嵌入的 url="https://www.youtube.com/watch?v=DTR3PzRRtYU" %}

### 第二部分 - 从 USB 驱动器安装 Ubuntu 20.04

{% 嵌入的 url="https://www.youtube.com/watch?v=C97\_6MrufCE" %}

您可以通过 USB 键将预制的 eth2矿床-cli 二进制计算机从在线机器复制到从丈夫启动的空格离线机器。 确保断开以太网电缆和/或WIFI。
{% endtab %}
{% endtabs %}

2. 跟随提示并选择密码。 请写下您的助记符并保持这个安全并且 **离线**。

3. 跳过您刚刚完成的步骤时，请在 [https://launchpad.eferum.org/](https://launchpad.ethereum.org/) 上按照这些步骤。 研究eth2阶段0概览材料。 了解eth2是成功的关键！

4. 返回启动板网站，上传您的`deposit_data-#########.json` 在 `validator_key` 目录中找到。

5. 使用您的Metamask钱包连接到启动板，审查并接受条款。

6. 确认交易\(s\)。 每个验证器有一个32个ETH的存款交易。

{% hint style="info" %}
您的交易是将您的ETH发送到 [官方ETH2 存款合同地址。 ](https://blog.ethereum.org/2020/11/04/eth2-quick-update-no-19/)

**检查**, _两次检查_, _**三次检查**_ 官方的 Eth2 存款合同地址是否正确。[`0x000000219ab540356cB839Cbe05303d7705Fa`](https://etherscan.io/address/0x00000000219ab540356cbb839cbe05303d7705fa)
{% endhint %}

{% hint style="danger" %}
\*\*\*🔥 **临界加密提醒:** **保留你的 mnemonic, 保留你的 ETH。** :火箭:

* 写下您的助记种子 **离线**。 _不是电子邮件。 未云。_
* 多份更好. _最好存储在一个_ [_金属种子。_](https://jlopp.github.io/metal-bitcoin-storage-reviews/)
* 将来会从此助记符生成提款密钥。
* 将 **个离线备份**, 例如您的 **的 USB 密钥。`validator_key`** 目录。
{% endhint %}

## 🛸 3. Install a ETH1 node

{% hint style="info" %}
以太坊2.0需要连接到以太坊1.0，才能监视32个ETH验证器存款。 托管您自己的Ethereum 1.0 节点是最大限度地下放权力和尽量减少对因富拉等第三方依赖的最佳途径。
{% endhint %}

{% hint style="warning" %}
随后的步骤假定您已完成 [最佳做法安全指南。 ](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md)

🛑 不要以 **ROOT** 用户身份运行您的进程。 😱
{% endhint %}

您的选择 [**OpenEthereum**](https://www.parity.io/ethereum/)**** [**Geth**](https://geth.ethereum.org/)**,** [**别斯库**](https://besu.hyperledger.org/)**,** [**荷兰**](https://www.nethermind.io/) **或** [**Infura**](https://infura.io/)**.**

{% tabs %}
{% tab title="OpenEtherum\(parity\)" %}
{% hint style="info" %}
**OpenEtherum** - **目标是使用 **Rust 编程语言** 成为最快、最轻松和最安全的 Ethereum 客户端。 OpenEthereum 是在 GPLv3 下许可的，可以用于满足您所有的以太坊需要。
{% endhint %}

#### ⚙ 安装依赖关系

```text
sudo apt-get update
sudo apt-get install curl jq unzip -y
```

#### 🤖 Install OpenEthereum

查看最新版本： [https://github.com/openetherum/openetherum/releases](https://github.com/openethereum/openethereum/releases)

自动下载最新的 linux 版本，un-zip，添加执行权限并清理。

```bash
mkdir $HOME/openeyum
cd $HOME/openetherum
curl -s https://api.github.com/repos/openetherum/openetherum/releases/latest | jq -r ".assets[| select(. ). |.browser_download_url" | grep linux | xargs wget -q --show-progress
unzip -o openetherum*.zip
chmod +x openeythum
rm openetherum*.zip
```

⚙ **设置并配置 systemd**

运行下面的操作来创建一个 **单元文件** 来定义您的 `E1.service` 配置。

只需复制/粘贴以下内容。

```bash
cat > $HOME/eth1.service << EOF 
[Unit]
Description     = openethereum eth1 service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = $(echo $HOME)/openethereum/openethereum
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

{% hint style="info" %}
**Nimbus 特定配置**: 将以下标志添加到 **ExecStart** 行。

```bash
--ws-origins=all
```
{% endhint %}

移动单位文件到 `/etc/system/system/system` 并授予它权限。

```bash
sudo mv $HOME/eth1.service /etc/systemd/system/eth1.service
```

```bash
sudo chmod 644 /etc/systemd/system/eth1.service
```

运行以下以启用启动时自动启动。

```text
sudo systemctl daemon-reload
sudo systemctl 启用eth1
```

#### :chains：启动 OpenEthereum

```text
sudo systemctl 起始eth1
```
{% endtab %}

{% tab title="Geth" %}
{% hint style="info" %}
**Geth** - Go Ethereum 是 Ethereum 协议的三个原始实现\(与 C++ 和 Python\) 之一。 它是在 **Go**中写入的，完全开源并在 GNU LGPL v3 下被许可使用。
{% endhint %}

在 [https://github.com/efecum/go-thereyum/releases](https://github.com/ethereum/go-ethereum/releases) 查看最新版本说明

#### 🧬 从资源库安装

```text
sudo additional apt-reposite-y pa:etherum/eysuthum
sudo apt-get update -y
sudo apt-get install etherum -y
```

⚙ **设置并配置 systemd**

运行下面的操作来创建一个 **单元文件** 来定义您的 `E1.service` 配置。

只需复制/粘贴以下内容。

```bash
cat > $HOME/eth1.service << EOF 
[Unit]
Description     = geth eth1 service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = /usr/bin/geth --http --metrics --pprof
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

{% hint style="info" %}
**Nimbus 特定配置**: 将以下标志添加到 **ExecStart** 行。

```bash
--ws
```
{% endhint %}

移动单位文件到 `/etc/system/system/system` 并授予它权限。

```bash
sudo mv $HOME/eth1.service /etc/systemd/system/eth1.service
```

```bash
sudo chmod 644 /etc/systemd/system/eth1.service
```

运行以下以启用启动时自动启动。

```text
sudo systemctl daemon-reload
sudo systemctl 启用eth1
```

#### :chains：起始位置

```text
sudo systemctl 起始eth1
```
{% endtab %}

{% tab title="Besu" %}
{% hint style="info" %}
**超标贝苏** 是一个开源的 Ethereum 客户端，其目的是要求在私人网络中进行安全的、高性能的交易处理。 它是在 Apache 2.0 许可下开发的，并在 **Java** 中写出。
{% endhint %}

#### 🧬 安装 java 依赖项

```text
sudo apt update
sudo apt install openjdk-11-jdk -y
```

#### 🌜 下载并unzip Besu

查看最新版本： [https://github.com/hyledger/besu/releases](https://github.com/hyperledger/besu/releases)

文件可以从 [https://dl.bintry.com/hyledger-org/besu-repo](https://dl.bintray.com/hyperledger-org/besu-repo) 下载。

```text
cd
wget -O besu.tar.gz https://dl.bintry.com/hyperledger-org/besu-repo/besu-20.10.1.tar.gz
tar -xvf besu.tar.gz
rm besu.tar.gz
mv besu* besu
```

⚙ **设置并配置 systemd**

运行下面的操作来创建一个 **单元文件** 来定义您的 `E1.service` 配置。

只需复制/粘贴以下内容。

```bash
cat > $HOME/eth1.service << EOF 
[Unit]
Description     = openethereum eth1 service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = $(echo $HOME)/besu/bin/besu --metrics-enabled --rpc-http-enabled --data-path="$HOME/.besu"
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

移动单位文件到 `/etc/system/system/system` 并授予它权限。

```bash
sudo mv $HOME/eth1.service /etc/systemd/system/eth1.service
```

```bash
sudo chmod 644 /etc/systemd/system/eth1.service
```

运行以下以启用启动时自动启动。

```text
sudo systemctl daemon-reload
sudo systemctl 启用eth1
```

#### :chains：启动besu

```text
sudo systemctl 起始eth1
```
{% endtab %}

{% tab title="Nethermind" %}
{% hint style="info" %}
**荷兰认为** 是一个关于性能和灵活性的龙头爱心客户端。 基于 **。 ET** 核心，一个广泛的、有利于企业的平台，荷兰认为与现有基础设施的整合很简单，同时不忽视稳定性、可靠性、数据完整性和安全性。
{% endhint %}

#### ⚙ 安装依赖关系

```text
sudo apt-get 更新
sudo apt-get install libsnappy-dev libc6-dev jq unzip -y
```

#### 🌜 下载并取消zip Netherlands

查看最新版本： [https://github.com/NethermindEth/nethermind/releases](https://github.com/NethermindEth/nethermind/releases)

自动下载最新的 Linux 版本，un-zip 和清理。

```bash
mkdir $HOME/内温思维 
cd $HOME/内温思维
curl -s https://api.github.com/repos/NethermindEth/nethermind/releases/最新| jq -r sets[] | select(.name) | .browser_download_url" | grep linux | xargs wget -q --show-progress
unzip -o nethermind.*.zip
rm nethermind*linux*.zip
```

⚙ **设置并配置 systemd**

运行下面的操作来创建一个 **单元文件** 来定义您的 `E1.service` 配置。

只需复制/粘贴以下内容。

```bash
cat > $HOME/eth1.service << EOF 
[Unit]
Description     = openethereum eth1 service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = $(echo $HOME)/nethermind/Nethermind.Runner --baseDbPath $HOME/.nethermind --Metrics.Enabled true --JsonRpc.Enabled true --Sync.DownloadBodiesInFastSync true --Sync.DownloadReceiptsInFastSync true --Sync.AncientBodiesBarrier 11052984 --Sync.AncientReceiptsBarrier 11052984
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

移动单位文件到 `/etc/system/system/system` 并授予它权限。

```bash
sudo mv $HOME/eth1.service /etc/systemd/system/eth1.service
```

```bash
sudo chmod 644 /etc/systemd/system/eth1.service
```

运行以下以启用启动时自动启动。

```text
sudo systemctl daemon-reload
sudo systemctl 启用eth1
```

#### :chains：开始考虑荷兰问题

```text
sudo systemctl 起始eth1
```
{% endtab %}

{% tab title="最小硬件设置\(Infura\)" %}
{% hint style="info" %}
Infura适合有限的磁盘空间设置。 在可能时总是运行您自己的完整的 eth1 节点。
{% endhint %}

在 [https://infura.io/](https://infura.io/) 注册API访问密钥

1. 注册免费帐户。
2. 确认您的电子邮件地址。
3. 访问您的仪表板 [https://infura.io/控制面板](https://infura.io/dashboard)
4. 创建一个项目，给它一个名称。
5. 选择 **Mainnet** 作为ENDPOINT
6. 按照下面您的 eth2 客户端的特定配置。

{% hint style="success" %}
或者，在 [https://eyseumnodes.com/](https://ethereumnodes.com/) 上使用一个免费的Ethereum 节点
{% endhint %}

## Nimbus 特定配置

1. 当创建您的系统的 **单元文件**, 更新 `--web-url` 带此端点的参数。
2. 复制 websocket 端点。 开始于 `wss://`
3. 将此保存到步骤4，配置您的 eth2 节点。

```bash
#example
--web3-url=<your wss:// infura endpoint>
```

## Teku 特定配置

1. After creating the `teku.yaml` located in `/etc/teku/teku.yaml`, update the `--eth1-endpoint` parameter with this endpoint.
2. 复制 http 端点。 以 `http://` 开始
3. 将此保存到步骤4，配置您的 eth2 节点。

```bash
#example
eth1-endpoint: <your https:// infura endpoint>
```

## 灯塔特定配置

1. 创建您的 **信标链系统** **单位文件**时，添加此端点的 `--eth1-endpoint` 参数。
2. 复制 **https** 端点。 开始于 `https://`
3. 将此保存到步骤4，配置您的 eth2 节点。

```bash
#example
--eth1-endpoint=<your https:// infura endpoint>
```

## Prysm 特定配置

1. 创建您的 **信标链系统设备文件**，更新 `--http-web3provider` 参数与此端点。
2. 复制 **https** 端点。 开始于 `https://`
3. 将此保存到步骤4，配置您的 eth2 节点。

```bash
#example
--http-web3provider=<your https:// infura endpoint>
```
{% endtab %}
{% endtabs %}

{% hint style="info" %}
同步一个 eth1 节点可能需要 1 个星期。 高端机器使用千兆位互联网，预期同步时间不到一天。
{% endhint %}

{% hint style="success" %}
发生这些事件时，您的 eth1 节点已完全同步。

* **`OpenEthereum:`** `Imported #<block number>`
* **`Geth：`** `导入了新链段`
* **`此外:`** `导入的 #<block number>`
* **`荷兰：`** `不再同步旧头`
{% endhint %}

#### 🛠 帮助的 eth1.service 命令

:spiral_notepad： **查看并关注eth1日志**

```text
journalctl -u eth1 -f
```

:spiral_notepad： **停止eth1服务**

```text
sudo systemctl stop eth1
```

## 🌜 4. 配置ETH2 信标链节点和验证器

您对灯塔、宁巴斯、泰库、普里斯姆或洛德斯姆的选择。

{% tabs %}
{% tab title="Lighthouse" %}
{% hint style="info" %}
[Lightthouse](https://github.com/sigp/lighthouse) 是一个 Eth2.0 客户端，对速度和安全性的高度重视。 背后的团队， [Sigma Prime](https://sigmaprime.io/)， 这是一家信息安全和软件工程公司，它向灯塔连同埃瑟姆基金会共识和个人提供了资金。 灯塔是用Rust构建的，提供给Apache 2.0 许可的。
{% endhint %}

## ⚙ 4.1. 安装rust依赖关系

```bash
curl --proto '=https' --tlsv1.2-sSf https://sh.rustup.rustup.rs | sh
```

输入 '1' 开始默认安装。

更新您的环境变量。

```bash
echo export PATH="$HOME/.cargo/bin:$PATH" >> ~/.bashrc
source ~/.bashrc
```

安装rust依赖项。

```text
sudo apt-get update
sudo apt install -y git gcc ++ make pkg-config libssl-dev
```

## 💡 4.2. 从源代码构建光线

```bash
mkdir ~/git
cd ~/git
git clone https://github.com/sigp/lightthouse。 它
cd lightthouse
git 抓取--all && git 签出稳定 && git 拉取
make
```

{% hint style="info" %}
如果出现编译错误，请运行以下序列。

```text
迅猛更新
个货运清理

```
{% endhint %}

{% hint style="info" %}
此构建过程可能需要几分钟。
{% endhint %}

通过检查版本号来验证灯塔已正确安装。

```text
lightthouse --版本
```

## 🎩 4.3. 导入验证器密钥

{% hint style="info" %}
当您导入您的密钥到 Lightthouse 时，您的验证签名密钥\(s\) 存储在 `$HOME/.lightthouse/mainnet/validators` 文件夹中。
{% endhint %}

运行下面的命令从Eth2dosit-cli工具目录导入您的验证器密钥。

输入您的密钥库密码以导入帐户。

```bash
lightthouse 帐户验证器导入 --net-directory=$HOME/eth2dosit-cli/validator_key_keys
```

验证帐户已成功导入。

```bash
lightthouse account_manager validator list --network mainnet
```

{% hint style="danger" %}
**警告**: 不要使用普通钥匙。不要使用其他密钥。或者你想要使用其他密钥。
{% endhint %}

## 🔥 4.4. 配置端口转发和/或防火墙

针对您的网络设置或云端提供商设置， [确保您的验证器防火墙端口是打开和可访问的。](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md#configure-your-firewall)

* **灯塔信标链** 需要端口9000端口才能使用 tcp 和 udp
* **eth1** 节点需要 tcp 和 udp 的 30303 端口

{% hint style="info" %}
:sparkles： **端口转发提示：** 您需要转发并打开端口到您的验证器。 验证它使用 [https://www.yugetsignal.com/tools/open-ports/](https://www.yougetsignal.com/tools/open-ports/) 或 [https://canyousee.org/](https://canyouseeme.org/)。
{% endhint %}

## ⛓ 4.5. 启动信标链。

#### 🍰 使用系统为您的信标链带来的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 在计算机因维修、停电等而重启时自动启动信标链。
2. 自动重启崩溃信标链流程。
3. 最大限度地提高您的信标链的持续时间和性能。

#### 🛠 系统设置说明

运行以下以创建一个 **单元文件** 来定义您的`信标链。服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/beacon-chain.service << EOF 
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = $(which lighthouse) bn --staking --metrics --network mainnet
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

{% hint style="info" %}
\*\*\*🔥 **Lightthouse Pro 提示:** 在 **ExecStart** 行上，添加了 `--eth1-endpoint` 标记允许多余的eth1节点。 用逗号分隔。 请确保端点不会以尾随斜杠或`/` 移除它。

```bash
# 示例：
--eth1-endpoints http://localhost:8545,https://nodes.mewapio/rpc/eth,https://mainnet.eth.cloud.ava.do,https://mainnet.infura.io/v3/xxx
```
{% endhint %}

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```

运行以下以启用启动时自动启动，然后启动您的信标节点服务。

```text
sudo systemctl daemon-reload
sudo systemctl 启用信标-chain
sudo systemctl start 信标-chain
```

{% hint style="info" %}
**故障排除常见问题**:

_信标链无法连接到 :8545 服务？_

* 在 \[Service\]信标链单元文件中，添加，`ExecStartPre = /bin/sleep 30`", 因此它将等待30秒的 eth1 节点启动后再连接。

_CRIT invalide eth1 chain id。 请切换到正确的链条ID。_

* 允许您的 eth1 节点完全同步到主网。
{% endhint %}

{% hint style="success" %}
好工作。 您的信标链现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查信标链是否激活

```text
sudo systemctl is-acon-chain
```

#### 🔎 查看信标链的状态

```text
sudo systemctl 状态信标
```

#### :countrockwise_arrows_buton: 重新启动信标链。

```text
sudo systemctl 重新加载或重新启动信标
```

#### 🛑 停止信标链中

```text
sudo systemctl stop 信标-chain
```

#### 🗄 查看和过滤日志

```bash
#view and follows the log
journalctl --unit=beacon-chain -f
#view log since 昨日
journalctl --unit=beacon-chain --since --avail=
#viewlog since 今日
journalctl --unit=beacon-chain --since = 今日
#viewlogs between a date
journalctl --unit=beacon-chain --sin='202020-12-01 00:00:00' --until='202020-12-02 12:00'
```

## 🧬 4.6. 启动验证程序

#### :ro火箭: 设置涂鸦和 POAP

设置您的 `个图画`，一个包含在您验证器的块中的自定义消息，并且获得一个 POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

#### 🍰 使用系统给您的验证器带来的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 因维护、停电等原因重启计算机时自动启动验证程序。
2. 自动重启验证进程崩溃了。
3. 最大化您的验证程序的上传时间和性能。

#### 🛠 系统设置说明

运行以下以创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标链。 ervice
After = network-online。 arget 

[Service]
用户 = $(whoami)
ExecStart = $(Lightthouse) vc --neth mainnet --graffiti "${MY_GRAFFITI}" --metrics 
restart = 发生故障

[Install]
WantedBy = multi用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```

运行以下以启用启动时自动启动，然后启动您的验证器。

```text
sudo systemctl daemon-reload
sudo systemctl 启用验证器
sudo systemctl start validator
```

{% hint style="success" %}
好工作。 您的验证器现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查验证器是否激活

```text
sudo systemctl is-activated validator
```

#### 🔎 查看验证器状态

```text
sudo systemctl status validator
```

#### :countrockwise_arrows_buton: 重新启动验证器

```text
sudo systemctl 重新加载或重新启动验证器
```

#### 🛑 停止验证器

```text
sudo systemctl stop validator
```

#### 🗄 查看和过滤日志

```bash
#view and follow the log
journalctl --unit=validator -f
#view log since yesterday
journalctl --unit=validator --since=yesterday
#view log since today
journalctl --unit=validator --since=today
#view log between a date
journalctl --unit=validator --since='2020-12-01 00:00:00' --until='2020-12-02 12:00:00'
```
{% endtab %}

{% tab title="Nimbus" %}
{% hint style="info" %}
[Nimbus](https://our.status.im/tag/nimbus/) 是一个 Ethereum 2 的研究项目和客户端实现。 设计能够在嵌入式系统和个人移动设备上很好地运行，包括使用资源限制硬件的老式智能电话。 Nimbus 团队是来自 [的公司状态](https://status.im/about/) 的公司，这个公司最熟悉的 [他们的消息应用/wallet/Web3 浏览器](https://status.im/) 具有相同的名称。 Nimbus \(Apache 2\) 是用Nim写成的，一种类似Python的语法编译到C的语言。
{% endhint %}

## ⚙ 4.1. 从源代码构建Nimbus

安装依赖项。

```text
sudo apt-get update
sudo apt-get install curl build-essential git -y
```

安装和构建Nimbus。

```bash
mkdir ~/git 
cd ~/git
git clone https://github.com/status-im/nimbus-eth2
cd nimbus-eth2
make NIMFLAGS="-d:pescure" nimbus_beacon_node
```

{% hint style="info" %}
构建过程可能需要几分钟。
{% endhint %}

通过显示帮助来验证Nimbus已正确安装。

```bash
cd $HOME/git/nimbus-eth2/build
./nimbus_beacon_node --help
```

复制二进制文件到 `/usr/bin`

```bash
sudo cp $HOME/git/nimbus-eth2/build/nimbus_beacon_node /usr/bin
```

## 🎩 4.2. 导入验证器密钥 <a id="6-import-validator-key"></a>

创建目录结构以存储nimbus数据。

```bash
sudo mkdir -p /var/lib/nimbus
```

获取此目录的所有权并设置正确的权限级别。

```bash
sudo chown $(whoami):$(whoami) /var/lib/nimbus
sudo chmod 700 /var/lib/nimbus
```

以下命令将导入您的验证器密钥。

输入您的密钥库密码以导入帐户。

```bash
cd $HOME/git/nimbus-eth2
build/nimbus_beacon_node minorities importing --data-dir=/var/lib/nimbus $HOME/eth2存款-clik/cli/validator_keys
```

现在您可以通过目录列表验证帐户已成功导入。

```bash
ll /var/lib/nimbus/validators
```

您应该看到一个为您每个验证程序的 pubkey 命名的文件夹。

{% hint style="info" %}
当您将您的密钥导入到 Nimbus时，您的验证器签名密钥\(s\) 存储在 `/var/lib/nimbus` 文件夹中。 在 `保密下` 和 `验证器。`

`secrets` 文件夹含有允许您访问所有验证器密钥的常用秘密。

`验证器` 文件夹包含您的签名密钥存储\(s\) \(加密密钥\)。 密钥存储被验证器用作交换密钥的方法。

关于密钥和密钥库的更多信息，请在这里查看 [](https://blog.ethereum.org/2020/05/21/keys/)。
{% endhint %}

{% hint style="danger" %}
**警告**: 不要使用普通钥匙。不要使用其他密钥。或者你想要使用其他密钥。
{% endhint %}

## 🔥 4.3. 配置端口转发和/或防火墙

针对您的网络设置或云端提供商设置， [确保您的验证器防火墙端口是打开和可访问的。](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md#configure-your-firewall)

* **Nimbus 信标链节点** 将使用端口9000作为tcp 和 udp
* **eth1** 节点需要 tcp 和 udp 的 30303 端口

{% hint style="info" %}
:sparkles： **端口转发提示：** 您需要转发并打开端口到您的验证器。 验证它使用 [https://www.yugetsignal.com/tools/open-ports/](https://www.yougetsignal.com/tools/open-ports/) 或 [https://canyousee.org/](https://canyouseeme.org/)。
{% endhint %}

## 🏂 4.4. 启动信标链和验证器

{% hint style="info" %}
Nimbus将信标链和验证器合并为一个过程。
{% endhint %}

#### :ro火箭: 设置涂鸦和 POAP

设置您的 `个图画`，一个包含在您验证器的块中的自定义消息，并且获得一个 POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

#### 🍰 为您的信标链和验证器使用系统的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 在计算机因维修、停电等而重启时自动启动信标链。
2. 自动重启崩溃信标链流程。
3. 最大限度地提高您的信标链的持续时间和性能。

#### 🛠 设置说明

运行以下以创建一个 **单元文件** 来定义您的`信标链。服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/beacon-chain.service << EOF 
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
Type            = simple
User            = $(whoami)
WorkingDirectory= /var/lib/nimbus
ExecStart       = /bin/bash -c '/usr/bin/nimbus_beacon_node --network=mainnet --graffiti="${MY_GRAFFITI}" --data-dir=/var/lib/nimbus --web3-url=ws://127.0.0.1:8546 --metrics --metrics-port=8008 --rpc --rpc-port=9091 --validators-dir=/var/lib/nimbus/validators --secrets-dir=/var/lib/nimbus/secrets --log-file=/var/lib/nimbus/beacon.log'
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

{% hint style="warning" %}
Nimbus只支持 ETH1 节点的 websocket 连接\("ws://" 和 "wss://"\")。 Geth, OpenEthereum 和 Infura ETH1 节点是验证兼容的。
{% endhint %}

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```

运行以下以启用启动时自动启动，然后启动您的信标节点服务。

```text
sudo systemctl daemon-reload
sudo systemctl 启用信标-chain
sudo systemctl start 信标-chain
```

{% hint style="success" %}
好工作。 您的信标链现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查信标链是否激活

```text
sudo systemctl is-acon-chain
```

#### 🔎 查看信标链的状态

```text
sudo systemctl 状态信标
```

#### :countrockwise_arrows_buton: 重新启动信标链。

```text
sudo systemctl 重新加载或重新启动信标
```

#### 🛑 停止信标链中

```text
sudo systemctl stop 信标-chain
```

#### 🗄 查看和过滤日志

```bash
#view and follows the log
journalctl --unit=beacon-chain -f
#view log since 昨日
journalctl --unit=beacon-chain --since --avail=
#viewlog since 今日
journalctl --unit=beacon-chain --since = 今日
#viewlogs between a date
journalctl --unit=beacon-chain --sin='202020-12-01 00:00:00' --until='202020-12-02 12:00'
```
{% endtab %}

{% tab title="Teku" %}
{% hint style="info" %}
[PegaSys Teku](https://pegasys.tech/teku/) \(前称Artemis\) 是基于 JavaScript 2.0 的客户端，它是为满足机构需要和安全要求而构建的 &。 PegaSys 是 [共识](https://consensys.net/) 的一个分支，致力于建立准备好企业的客户端和与核心Ethereum 平台互动的工具。 Teku 是 Apache 2 授权并以 Java 写，它是一种显著的产物 & 无所不在的语言。
{% endhint %}

## ⚙ 4.1 从源代码构建Teku

Install git.

```text
sudo apt-get install git -y
```

安装 Java 11。

对于 **Ubuntu 20.x**，请使用以下内容

```
sudo apt update
sudo apt install openjdk-11-jdk -y
```

对于 **Ubuntu 18.x**，请使用以下内容

```text
sudo 附加apt-replies pa:linuxurising/java
sudo apt updat更新
sudo apt install oracle-java11-set-default -y
```

验证 Java 11+ 已安装。

```bash
java --version
```

安装并构建Teku。

```bash
mkdir ~/git
cd ~/git
git clone https://github.com/Consensions/teku.git
cd teku
./gradlew distt Tar installDist
```

{% hint style="info" %}
此构建过程可能需要几分钟。
{% endhint %}

通过显示版本来验证Teku。

```bash
cd $HOME/git/teku/build/install/teku/bin
./teku --version
```

复制 teku 二进制文件到 `/usr/bin/teku`

```bash
sudo cp -r $HOME/git/teku/build/install/teku /usr/bin/teku
```

## 🔥 4.2. 配置端口转发和/或防火墙

针对您的网络设置或云端提供商设置， [确保您的验证器防火墙端口是打开和可访问的。](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md#configure-your-firewall)

* **Teku 信标链节点** 将使用端口 9000 到 tcp 和 udp
* **eth1** 节点需要 tcp 和 udp 的 30303 端口

{% hint style="info" %}
\*\*\*✨ **端口转发提示:** 你需要转发并打开端口到你的验证器。 验证它使用 [https://www.yugetsignal.com/tools/open-ports/](https://www.yougetsignal.com/tools/open-ports/) 或 [https://canyousee.org/](https://canyouseeme.org/)。
{% endhint %}

## 🏂 4.3. 配置信标链和验证器

{% hint style="info" %}
Teku将信标链和验证器合并为一个过程。
{% endhint %}

设置Teku目录结构。

```bash
sudo mkdir -p /var/lib/teku
sudo mkdir -p /etc/teku
sudo chown $(whoami):$(whoami) /var/lib/teku
```

 将您的 `validator_files` 目录复制到我们在上面创建的数据目录，并删除额外的Depositer\_data 文件。

```bash
cp -r $HOME/eth2存款-clik/validator_key/var/lib/teku
rm /var/lib/teku/validator_keys/deposit_data *
```

{% hint style="danger" %}
**警告**: 不要使用普通钥匙。不要使用其他密钥。或者你想要使用其他密钥。
{% endhint %}

将您的验证程序密码存储在一个文件中。

在 `echo` 之后更新引号之间的密码。

```bash
echo 'my_password_goes_here' > $HOME/validators-password.txt
sudo mv $HOME/validators-password.txt /etc/teku/validators-password.txt
```

#### :ro火箭: 设置涂鸦和 POAP

设置您的 `个图画`，一个包含在您验证器的块中的自定义消息，并且获得一个 POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

生成您的 Teku 配置文件。 只复制和粘贴。

```bash
cat > $HOME/teku.yaml << EOF
# network
network: "mainnet"

# p2p
p2p-enabled: true
p2p-port: 9000
# validators
validator-keys: "/var/lib/teku/validator_keys:/var/lib/teku/validator_keys"
validators-graffiti: "${MY_GRAFFITI}"

# Eth 1
eth1-endpoint: "http://localhost:8545"

# metrics
metrics-enabled: true
metrics-port: 8008

# database
data-path: "$(echo $HOME)/tekudata"
data-storage-mode: "archive"

# rest api
rest-api-port: 5051
rest-api-docs-enabled: true
rest-api-enabled: true

# logging
log-include-validator-duties-enabled: true
log-destination: CONSOLE
EOF
```

移动配置文件到 `/etc/teku`

```bash
sudo mv $HOME/teku.yaml /etc/teku/teku.yaml
```

## :top_hat：4.4 导入验证器密钥

{% hint style="info" %}
当为您的验证器键指定目录时，Teku需要找到相同名称的密钥库和密码文件。

例如： `keystore-m_12221_3600_1_0_0-1122233.json` and `keystore-m_12221_3600_1_0_0-1122233.txt`
{% endhint %}

为每一个验证程序创建一个相应的密码文件。

```bash
f 在 /var/lib/teku/validator_keys/keystore*.json; do cp /etc/teku/validators-password.txt /var/lib/teku/validator_keys/$(basename $f .json).txt; 完成
```

通过检查下面的目录来验证您的验证器的密钥和验证器密码是否存在。

```bash
ll /var/lib/teku/validator_keys
```

## 🏁 4.5. 启动信标链和验证器

使用 **systemd** 来管理开始和停止teku。

#### 🍰 为您的信标链和验证器使用系统的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 在计算机因维修、停电等而重启时自动启动信标链。
2. 自动重启崩溃信标链流程。
3. 最大限度地提高您的信标链的持续时间和性能。

#### 🛠 设置说明

运行以下以创建一个 **单元文件** 来定义您的`信标链。服务` 配置。

```bash
cat > $HOME/beacon-chain.service << EOF
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
ExecStart       = /usr/bin/teku/bin/teku -c /etc/teku/teku.yaml
Restart         = on-failure
Environment     = JAVA_OPTS=-Xmx5g

[Install]
WantedBy    = multi-user.target
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```

运行以下以启用启动时自动启动，然后启动您的信标节点服务。

```text
sudo systemctl daemon-reload
sudo systemctl 启用信标-chain
sudo systemctl start 信标-chain
```

{% hint style="success" %}
好工作。 您的信标链现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查信标链是否激活

```text
sudo systemctl is-acon-chain
```

#### 🔎 查看信标链的状态

```text
sudo systemctl 状态信标
```

#### :countrockwise_arrows_buton: 重新启动信标链。

```text
sudo systemctl 重新加载或重新启动信标
```

#### 🛑 停止信标链中

```text
sudo systemctl stop 信标-chain
```

#### 🗄 查看和过滤日志

```bash
#view and follows the log
journalctl --unit=beacon-chain -f
#view log since 昨日
journalctl --unit=beacon-chain --since --avail=
#viewlog since 今日
journalctl --unit=beacon-chain --since = 今日
#viewlogs between a date
journalctl --unit=beacon-chain --sin='202020-12-01 00:00:00' --until='202020-12-02 12:00'
```
{% endtab %}

{% tab title="Prysm" %}
{% hint style="info" %}
[Prysm](https://github.com/prysmaticlabs/prysm) 是一个 Ethereum 2.0 协议的实现，以可用性、安全性和可靠性为重点。 Prysm是由 [Prysmatic Labs](https://prysmaticlabs.com/)开发的，是一家完全关注客户发展的公司。 Prysm是以 Go 写的，并在 GPL 3.0 许可下发布。
{% endhint %}

## ⚙ 4.1. Install Prysm

```bash
mkdir ~/prysm && cd ~/prysm 
curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh && chmod +x prysm.sh 
```

## 🔥 4.2. 配置端口转发和/或防火墙

针对您的网络设置或云端提供商设置， [确保您的验证器防火墙端口是打开和可访问的。](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md#configure-your-firewall)

* **Prysm 信标链节点** 将使用端口 12000 用于udp 和 tcp 端口13000
* **eth1** 节点需要 tcp 和 udp 的 30303 端口

{% hint style="info" %}
:sparkles： **端口转发提示：** 您需要转发并打开端口到您的验证器。 验证它使用 [https://www.yugetsignal.com/tools/open-ports/](https://www.yougetsignal.com/tools/open-ports/) 或 [https://canyousee.org/](https://canyouseeme.org/)。
{% endhint %}

## 🎩 4.3. 导入验证器密钥

接受使用条款，接受默认的钱包位置，输入新密码来加密你的钱包，并为你的导入帐户输入密码。

```bash
$HOME/prysm/prysm.sh 验证帐户导入 --mainnet --keys-dir=$HOME/eth2存款-cli/validator_keys
```

验证已成功导入。

```bash
$HOME/prysm/prysm.sh 验证帐户列表 --mainnet
```

确认您的验证程序的 pubkeys 已列出。

> \#示例输出：
> 
> 显示 1 个验证帐户。通过运行 \`validator 帐户列表 --show-dosit-data 查看您帐户的 eth1 存入交易数据
> 
> 帐户 0 \| pens-fri-hee   
> \[验证公钥\] 0x2374...7121

{% hint style="danger" %}
**警告**: 不要使用普通钥匙。不要使用其他密钥。或者你想要使用其他密钥。
{% endhint %}

## 🏂 4.4. 启动信标链。

#### 🍰 为您的信标链和验证器使用系统的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 在计算机因维修、停电等而重启时自动启动信标链。
2. 自动重启崩溃信标链流程。
3. 最大限度地提高您的信标链的持续时间和性能。

#### 🛠 设置说明

运行以下以创建一个 **单元文件** 来定义您的`信标链。服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/beacon-chain.service << EOF 
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
Type            = simple
User            = $(whoami)
ExecStart       = $(echo $HOME)/prysm/prysm.sh beacon-chain --mainnet --p2p-max-peers=75 --http-web3provider=http://127.0.0.1:8545 --accept-terms-of-use 
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```

运行以下以启用启动时自动启动，然后启动您的信标节点服务。

```text
sudo systemctl daemon-reload
sudo systemctl 启用信标-chain
sudo systemctl start 信标-chain
```

{% hint style="success" %}
好工作。 您的信标链现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查信标链是否激活

```text
sudo systemctl is-acon-chain
```

#### 🔎 查看信标链的状态

```text
sudo systemctl 状态信标
```

#### :countrockwise_arrows_buton: 重新启动信标链。

```text
sudo systemctl 重新加载或重新启动信标
```

#### 🛑 停止信标链中

```text
sudo systemctl stop 信标-chain
```

#### 🗒 查看和过滤日志

```bash
#view and follows the log
journalctl --unit=beacon-chain -f
#view log since 昨日
journalctl --unit=beacon-chain --since --avail=
#viewlog since 今日
journalctl --unit=beacon-chain --since = 今日
#viewlogs between a date
journalctl --unit=beacon-chain --sin='202020-12-01 00:00:00' --until='202020-12-02 12:00'
```

## 🧬 4.5. 启动验证程序 <a id="9-start-the-validator"></a>

将您的验证密码存储在一个文件中，并使其成为只读。

```bash
echo 'my_password_goes_here' > $HOME/.eth2validators/validators-password.txt
sudo chmod 600 $HOME/.eth2validators/validators-password.txt
```

#### :ro火箭: 设置涂鸦和 POAP

设置您的 `个图画`，一个包含在您验证器的块中的自定义消息，并且获得一个 POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

您选择从命令行手动运行验证器或与系统自动运行。

#### 🍰 使用系统给您的验证器带来的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 因维护、停电等原因重启计算机时自动启动验证程序。
2. 自动重启验证进程崩溃了。
3. 最大化您的验证程序的上传时间和性能。

#### 🛠 系统设置说明

运行以下以创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标-chain.service
After = network-online。 arget 

[Service]
用户 = $(whoami)
ExecStart = $(echo $HOME)/prysm/prysm。 h validator --mainnet --graffiti "${MY_GRAFFITI}" --accept-terms of use --wallet-password-file $(echo $HOME)/. th2validators/validators-password xt
重启 = 发生故障

[Install]
WantedBy = 多用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```

运行以下以启用启动时自动启动，然后启动您的验证器。

```text
sudo systemctl daemon-reload
sudo systemctl 启用验证器
sudo systemctl start validator
```

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查验证器是否激活

```text
sudo systemctl is-activated validator
```

#### 🔎 查看验证器状态

```text
sudo systemctl status validator
```

#### :countrockwise_arrows_buton: 重新启动验证器

```text
sudo systemctl 重新加载或重新启动验证器
```

#### 🛑 停止验证器

```text
sudo systemctl stop validator
```

#### 🗄 查看和过滤日志

```bash
#view and follow the log
journalctl --unit=validator -f
#view log since yesterday
journalctl --unit=validator --since=yesterday
#view log since today
journalctl --unit=validator --since=today
#view log between a date
journalctl --unit=validator --since='2020-12-01 00:00:00' --until='2020-12-02 12:00:00'
```

验证您的 **验证器公钥** 是否出现在日志中。

```bash
journalctl --unit=validator --since = 今日
# 下面的示例
# INFO 启用 validator voting_pubkey: 0x2374...7121
```
{% endtab %}

{% tab title="Lodestar" %}
{% hint style="info" %}
**Lodestar is a Typescript implementation** of the official [Ethereum 2.0 specification](https://github.com/ethereum/eth2.0-specs) by the [ChainSafe.io](https://lodestar.chainsafe.io/) team. 除了信标链客户外，该小组还在22个软件包和图书馆工作。 完整的列表可以在这里找到 [](https://hackmd.io/CcsWTnvRS_eiLUajr3gi9g)。 末尾。 Lodestar小组正在领导Eth2空间的轻型客户研究和开发，并为此目的从EF和Moloch DAO获得资金。
{% endhint %}

{% hint style="danger" %}
Lodestar可能尚未完全运作和稳定。
{% endhint %}

## ⚙ 4.1 从源代码构建Lodestar

安装曲线和吉特。

```bash
sudo apt-get install git curl -y
```

安装 yarn。

```bash
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key 添加 -
echo "deb https://dl.yarnpkg. om/debian/stable main" | sudo tee /etc/apt/sources.list.d/yarn.list
sudo apt update
sudo apt install yarn
```

确认 yarn 已正确安装。

```bash
yarn --version
# 应该输出版本 >= 1.22.4
```

Install nodejs.

```text
curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
sudo apt-get install -y nodejs
```

确认 nodejs 已正确安装。

```bash
nodejs -v
# 输出版本 >= v12.18.3
```

安装和构建Lodestar。

```bash
mkdir ~/git
cd ~/git
git clone https://github.com/chainsafe/lodestar.git
cd lodestar
yarn instance
yarn run building
```

{% hint style="info" %}
此构建过程可能需要几分钟。
{% endhint %}

通过显示帮助菜单来验证Lodestar已正确安装。

```text
yarn 运行 cli --help
```

## 🔥 4.2. 配置端口转发和/或防火墙

针对您的网络设置或云端提供商设置， [确保您的验证器防火墙端口是打开和可访问的。](guide-or-security-best-practices-for-a-eth2-validator-beaconchain-node.md#configure-your-firewall)

* **Lodestar 信标链节点** 将使用端口 30607用于tcp 和 port 9000 用于udp 对等点。
* **eth1** 节点需要 tcp 和 udp 的 30303 端口

{% hint style="info" %}
\*\*\*✨ **端口转发提示:** 你需要转发并打开端口到你的验证器。 验证它使用 [https://www.yugetsignal.com/tools/open-ports/](https://www.yougetsignal.com/tools/open-ports/) 或 [https://canyousee.org/](https://canyouseeme.org/)。
{% endhint %}

## 🎩 4.3. 导入验证器密钥

```bash
yarn 运行cli 帐户验证器导入
  --net!
  --directory $HOME/eth2存款-cli/validator_keys
```

输入您的密钥库密码以导入帐户。

确认您的密钥已正确导入。

```text
yarn 运行 cli 帐户验证器列表 --network mainnet
```

{% hint style="danger" %}
**警告**: 不要使用普通钥匙。不要使用其他密钥。或者你想要使用其他密钥。
{% endhint %}

## 🏂 4.4. 启动信标链和验证器

使用系统自动运行信标链。

#### 🍰 使用系统为您的信标链带来的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 在计算机因维修、停电等而重启时自动启动信标链。
2. 自动重启崩溃信标链流程。
3. 最大限度地提高您的信标链的持续时间和性能。

#### 🛠 设置说明

运行以下以创建一个 **单元文件** 来定义您的`信标链。服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/beacon-chain.service << EOF 
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
User            = $(whoami)
WorkingDirectory= $(echo $HOME)/git/lodestar
ExecStart       = yarn run cli beacon --network mainnet --eth1.providerUrl http://localhost:8545 --metrics.serverPort 8008
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```

运行以下以启用启动时自动启动，然后启动您的信标节点服务。

```text
sudo systemctl daemon-reload
sudo systemctl 启用信标-chain
sudo systemctl start 信标-chain
```

{% hint style="success" %}
好工作。 您的信标链现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查信标链是否激活

```text
sudo systemctl is-acon-chain
```

#### 🔎 查看信标链的状态

```text
sudo systemctl 状态信标
```

#### :countrockwise_arrows_buton: 重新启动信标链。

```text
sudo systemctl 重新加载或重新启动信标
```

#### 🛑 停止信标链中

```text
sudo systemctl stop 信标-chain
```

#### 🗄 查看和过滤日志

```bash
#view and follows the log
journalctl --unit=beacon-chain -f
#view log since 昨日
journalctl --unit=beacon-chain --since --avail=
#viewlog since 今日
journalctl --unit=beacon-chain --since = 今日
#viewlogs between a date
journalctl --unit=beacon-chain --sin='202020-12-01 00:00:00' --until='202020-12-02 12:00'
```

## 🧬 4.5. 启动验证程序

#### :ro火箭: 设置涂鸦和 POAP

设置您的 `个图画`，一个包含在您验证器的块中的自定义消息，并且获得一个 POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

使用系统自动运行验证器。

#### 🍰 使用系统给您的验证器带来的利益 <a id="benefits-of-using-systemd-for-your-stake-pool"></a>

1. 因维护、停电等原因重启计算机时自动启动验证程序。
2. 自动重启验证进程崩溃了。
3. 最大化您的验证程序的上传时间和性能。

#### 🛠 设置说明

运行以下以创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标-chain.service
After = network-online。 arget 

[Service]
用户 = $(whoami)
WorkingDirectory= $(echo $HOME)/git/lodestar
ExecStart = yarn run cli validator run --network mainnet --graffiti "${MY_GRAFFITI}"
Restart = 发生故障

[Install]
WantedBy = multi用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```

运行以下以启用启动时自动启动，然后启动您的验证器。

```text
sudo systemctl daemon-reload
sudo systemctl 启用验证器
sudo systemctl start validator
```

{% hint style="success" %}
好工作。 您的验证器现在由系统的可靠性和强度管理。 下面是一些使用系统的命令。
{% endhint %}

### 🛠 一些有用的systemd 命令

#### :whit_heavy_check_mark: 检查验证器是否激活

```text
sudo systemctl is-activated validator
```

#### 🔎 查看验证器状态

```text
sudo systemctl status validator
```

#### :countrockwise_arrows_buton: 重新启动验证器

```text
sudo systemctl 重新加载或重新启动验证器
```

#### 🛑 停止验证器

```text
sudo systemctl stop validator
```

#### 🗄 查看和过滤日志

```bash
#view and follow the log
journalctl --unit=validator -f
#view log since yesterday
journalctl --unit=validator --since=yesterday
#view log since today
journalctl --unit=validator --since=today
#view log between a date
journalctl --unit=validator --since='2020-12-01 00:00:00' --until='2020-12-02 12:00:00'
```
{% endtab %}
{% endtabs %}

{% hint style="info" %}
**验证器客户端** - 负责在信标链和碎片链中生成新区块和认证。

**信标链客户端** - 负责管理信标链状态、验证器随机排序等等。

记住、Teku和Nimbus将两个客户合并为一个过程。
{% endhint %}

{% hint style="success" %}
恭喜。 一旦您的信标链已同步，验证器已上传并运行，您只需等待激活。 此过程可能需要 24 + 个小时。 每天只有900个新验证程序可以加入。 当你被指派时，你的验证器将开始创建和投票块，同时获得预订奖励。

使用 [https://信标.in/](https://beaconcha.in/) 来创建警报并跟踪您的验证器性能。
{% endhint %}

## 🕒5. 时间同步

{% hint style="info" %}
因为信标链依靠准确的时间来进行证明和制作区块， 您的计算机时间必须准确到实际NTP 或 NTS 时间在 0 之间。 秒。
{% endhint %}

安装 **Chrony** 带有以下指南。

{% page-ref page="../overview.ada/guide-how to build-a-haskell-stakpool-node/how to setup-chrony.md" %}

{% hint style="info" %}
时间是网络时间协议的执行，有助于使您的计算机时间与NTP保持同步。
{% endhint %}

## 🔎6. 用Grafana 和 Prometheus 监视您的验证器

Prometheus 是一个监测平台，它通过拆卸关于这些目标的计量标准HTTP端点，从受监测的目标收集计量。 [官方文档可在这里获取](https://prometheus.io/docs/introduction/overview/) Grafana 是一个用于可视化收集数据的仪表盘。

### 🐣 6.1 安装

安装 prometheus 和 prometheus 节点导出器。

```text
sudo apt-get install -y promeus promeus-node-exporter
```

安装Grafana。

```bash
wget -q -O - https://pack.grafana.com/gpg.key | sudo apt-key added -
echo "deb https://packes.grafana.com/oss/deb stable main" > grafana. ist
sudo mv grafana.list /etc/apt/sources.list.d/grafana.list
sudo apt-get update && sudo apt-get install -y grafana
```

启用服务以便自动启动。

```bash
sudo systemctl 启用gramana-server.service prometheus.service prometheus-node-exportter.service
```

创建 **promeus.yml** 配置文件。 选择您的 eth2 客户端的标签。 只复制和粘贴。

{% tabs %}
{% tab title="Lighthouse" %}
```bash
cat > $HOME/prometheus.yml << EOF
global：
  scrape_interval: 15s # 默认情况下，扫描每15秒。

  # 在与
  # 外部系统通信时将这些标签附加到任何时间序列或警报(排序、远程存储、警报管理器)。
  外部标签：
    显示器：'codelab-monitor'

# 一个包含到scrape的一个端点的扫描配置：
# 这里是Prometheus本身。
scrape_configs:
   - job_name: 'node_exporter'
     static_configs:
       - targets: ['localhost:9100']
   - job_name: 'nodes'
     metrics_path: /metrics    
     static_configs:
       - targets: ['localhost:5054']
   - job_name: 'validators'
     metrics_path: /metrics
     static_configs:
       - targets: ['localhost:5064']
EOF
```
{% endtab %}

{% tab title="Nimbus" %}
```bash
cat > $HOME/prometheus.yml << EOF
global：
  scrape_interval: 15s # 默认情况下，扫描每15秒。

  # 在与
  # 外部系统通信时将这些标签附加到任何时间序列或警报(排序、远程存储、警报管理器)。
  外部标签：
    显示器：'codelab-monitor'

# 一个包含到scrape的一个端点的扫描配置：
# 这里是Prometheus本身。
scrape_configs:
   - job_name: 'node_exportter'
     static_configs:
       - targets: ['localhost:9100']
   - job_name: 'nodes'
     metrics_path: /metrics    
     static_configs:
       - targets: ['localhost:8008']
EOF
```
{% endtab %}

{% tab title="Teku" %}
```bash
cat > $HOME/prometheus.yml << EOF
global：
  scrape_interval: 15s # 默认情况下，扫描每15秒。

  # 在与
  # 外部系统通信时将这些标签附加到任何时间序列或警报(排序、远程存储、警报管理器)。
  外部标签：
    显示器：'codelab-monitor'

# 一个包含到scrape的一个端点的扫描配置：
# 这里是Prometheus本身。
scrape_configs:
   - job_name: 'node_exportter'
     static_configs:
       - targets: ['localhost:9100']
   - job_name: 'nodes'
     metrics_path: /metrics    
     static_configs:
       - targets: ['localhost:8008']
EOF
```
{% endtab %}

{% tab title="Prysm" %}
```bash
cat > $HOME/prometheus.yml << EOF
global：
  scrape_interval: 15s # 默认情况下，扫描每15秒。

  # 在与
  # 外部系统通信时将这些标签附加到任何时间序列或警报(排序、远程存储、警报管理器)。
  外部标签：
    显示器：'codelab-monitor'

# 一个包含到scrape的一个端点的扫描配置：
# 这里是Prometheus本身。
scrape_configs:
  - job_name: 'node_exportter'
    static_configs:
      - targets: ['localhost:9100']
  - job_name: 'validator'
    static_configs:
      - targets: ['localhost:8081']
  - job_name: 'beacon node'
    static_configs:
      - targets: ['localhost:808080']
  - job_name: 'slasher'
    static_configs:
      - targets: ['localhost:8082']

```
{% endtab %}

{% tab title="Lodestar" %}
```bash
猫 > $HOME/prometheus。 ml << EOF   
scrape_configs:
   - job_name: 'node_exportter'
     static_configs:
       - 目标：['localhost:9100']
   - job_name: 'Lodestar'
     metrics_path: /metrics    
     static_configs:
       - targets: ['localhost:8008']
EOF
```
{% endtab %}
{% endtabs %}

为您的 **eth1 节点** 设置 promeus。 开始编辑 **promeus.yml**

```bash
nano $HOME/prometheus.yml
```

在 **prometheus.yml** 末尾添加您的 eth1 节点适用的作业片段。 保存文件。

{% tabs %}
{% tab title="Geth" %}
```bash
   - job_name: 'get'
     scrape_interval: 15s
     scrape_timeout: 10s
     metrics_path: /debug/metrics/prometheus
     scheme: http
     static_configs:
     - targets: ['localhost:606060']
```
{% endtab %}

{% tab title="Besu" %}
```bash
  - job_name: 'besu'
    scrape_interval: 15s
    scrape_timeout: 10s
    metrics_path: /metrics
    scheme: http
    static_configs:
    - targets:
      - localhost:9545
```
{% endtab %}

{% tab title="Nethermind" %}
```bash
   - job_name: 'nethermind'
    scrape_interval: 15s
    scrape_timeout: 10s
    pren_labels: true
    static_configs:
    - targets: ['localhost:9091']
```

荷兰的监测需要 [Prometheus Pushgateway](https://github.com/prometheus/pushgateway)。 使用以下命令安装。

```bash
sudo apt-get install -y promeus-pus-pus网关
```

{% hint style="info" %}
来自 Netherlands 的 9091 端口监听数据。
{% endhint %}
{% endtab %}

{% tab title="OpenEthereum" %}
```bash
正在进行的工作
```
{% endtab %}
{% endtabs %}

将其移动到 `/etc/prometheus.yml`

```bash
sudo mv $HOME/prometheus.yml /etc/prometheus.yml
```

最后，重新启动服务。

```bash
sudo systemctl 重启 grafana-server.service prometheus.service prometheus-node-exportter.service
```

验证服务运行正常：

```text
sudo systemctl status grafana-server.service prometheus.service prometheus-node-exportter.service
```

{% hint style="info" %}
💡 **提醒**: 如果您打算从另一台机器查看监视信息，请确保在防火墙和/或转发端口上打开3000端口。
{% endhint %}

### :natirna_bars：6.2 设置 Grafana 仪表板

1. 在您的本地浏览器中打开 [http://localhost:3000](http://localhost:3000) 或 http://&lt;your validator's ip address&gt;:3000。
2. 使用 **管理员** / **管理员登录**
3. 更改密码
4. 点击 **配置设备** 图标，然后 **添加数据源**
5. 选择 **Prometheus**
6. 将 **名称** 设置为 **"Prometheus**"
7. 将 **URL** 设置为 [http://localhost:9090](http://localhost:9090)
8. 点击 **保存 & 测试**
9. **下载并保存** 您的ETH2 Client json 文件。 \[ [Lightthouse BC ](https://raw.githubusercontent.com/sigp/lighthouse-metrics/master/dashboards/Summary.json)\| [Lightthouse VC](https://raw.githubusercontent.com/sigp/lighthouse-metrics/master/dashboards/ValidatorClient.json) \| [Teku ](https://grafana.com/api/dashboards/13457/revisions/2/download)\| [Nimbus ](https://raw.githubusercontent.com/status-im/nimbus-eth2/master/grafana/beacon_nodes_Grafana_dashboard.json)\| [Prysm ](https://raw.githubusercontent.com/GuillaumeMiralles/prysm-grafana-dashboard/master/less_10_validators.json)\| [Prysm &gt; 10 Validator](https://raw.githubusercontent.com/GuillaumeMiralles/prysm-grafana-dashboard/master/more_10_validators.json) \| Lodestar \]
10. **下载并保存** 你的ETH1 Client json 文件 \[ [Geth](https://gist.githubusercontent.com/karalabe/e7ca79abdec54755ceae09c08bd090cd/raw/3a400ab90f9402f2233280afd086cb9d6aac2111/dashboard.json) \| [Besu ](https://grafana.com/api/dashboards/10273/revisions/5/download)\| [Netherlands ](https://raw.githubusercontent.com/NethermindEth/metrics-infrastructure/master/grafana/dashboards/nethermind.json)\| OpenEtherum \]
11. 点击 **创建 +** 图标 &gt; **导入**
12. 通过 **添加 ETH2 客户端面板上传JSON 文件**
13. 如果需要，选择 Prometheus 为 **数据源**。
14. 点击 **导入** 按钮。
15. 对于ETH1客户端仪表盘重复步骤11-14。

{% hint style="info" %}
\*\*\*🔥 **疑难解答常见的Grafana 问题**:

_仪表板不显示eth1节点数据。_

* 在 **eth1 单元文件** 中，位于 `/etc/systemd/system/eth1。 ervice`, 请确保您的 eth1 节点/geth 以正确的参数开头, 以便启用报告计量和prof http 服务器.
  * Example:`ExecStartPre = /usr/bin/geth --http --metrics --pprof`
{% endhint %}

#### 每个ETH2客户端的 Grafana 仪表板示例。

{% tabs %}
{% tab title="Lighthouse" %}
![由签名显示的信标链面板](../../.gitbook/assets/lhm.png)

![通过签名验证客户端仪表板](../../.gitbook/assets/lighthouse-validator.png)

积分： [https://github.com/sigp/lightthouse-metrics/](https://github.com/sigp/lighthouse-metrics/)
{% endtab %}

{% tab title="Nimbus" %}
![按状态设置的仪表板](../../.gitbook/assets/nim_dashboard.png)

积分： [https://github.com/status-im/nimbus-eth2/](https://github.com/status-im/nimbus-eth2/)
{% endtab %}

{% tab title="Teku" %}
![Teku by PegaSys Engineering](../../.gitbook/assets/teku.dash.png)

积分： [https://grafana.com/grafana/dashboards/13457](https://grafana.com/grafana/dashboards/13457)
{% endtab %}

{% tab title="Prysm" %}
![Prysm 仪表板由 GuillaumeMiralles 提供](../../.gitbook/assets/prysm_dash.png)

积分： [https://github.com/GuillaumeMiralles/prysm-grafana-仪表板](https://github.com/GuillaumeMiralles/prysm-grafana-dashboard)
{% endtab %}

{% tab title="Lodestar" %}
正在进行的工作。
{% endtab %}
{% endtabs %}

#### 每一个 ETH 1 节点的 Grafana 仪表板示例。

{% tabs %}
{% tab title="Geth" %}
![按卡拉贝排列的仪表板](../../.gitbook/assets/geth-dash.png)

积分： [https://gist.github.com/karalabe/e7ca79abdec54755ceae09c08bd090cd](https://gist.github.com/karalabe/e7ca79abdec54755ceae09c08bd090cd)
{% endtab %}

{% tab title="Besu" %}
![](../../.gitbook/assets/besu-dash.png)

积分： [https://grafana.com/dashboards/10273](https://grafana.com/dashboards/10273)
{% endtab %}

{% tab title="Nethermind" %}
![](../../.gitbook/assets/nethermind-dash.png)

积分： [https://github.com/NethermindEth/metrics-infrastructures](https://github.com/NethermindEth/metrics-infrastructure)
{% endtab %}

{% tab title="OpenEthereum" %}
正在进行的工作
{% endtab %}
{% endtabs %}

### ⚠ 6.3 安装提醒通知

{% hint style="info" %}
设置提醒以在您的验证器离线时获得通知。
{% endhint %}

获取验证程序问题的通知。 选择电子邮件、电报、不和或是slack。

{% tabs %}
{% tab title="Email Notifications" %}
1. 访问 [https://信标.in/](https://beaconcha.in/)
2. 注册一个帐户。
3. 验证您的 **电子邮件**
4. 搜索您的 **验证器的公开地址**
5. 点击 **书签符号** 将验证器添加到您的观察列表。
{% endtab %}

{% tab title="Telegram Notifications" %}
1. 在 Grafana 菜单中，在铃声图标下选择 **个通知频道**。
2. 点击 **添加频道**。
3. 给通知频道一个 **名称**。
4. 从类型列表中选择 **Telegram**。
5. 要完成 **Telegram API 設置**, , 需要 **Telegram 頻道** 和 **機器人**。 关于使用 `@Botfather`的机器人设置的说明，请参阅 [Telegram 文档的](https://core.telegram.org/bots#6-botfather) 部分。 您需要创建 BOT API 令牌。
6. 创建一个新的电报组。
7. 邀请机器人加入您的新群组。
8. 输入至少1个消息以初始化它。
9. 访问 [`https://api.telegram.org/botXXX:YY/getUpdates`](https://api.telegram.org/botXXX:YYY/getUpdates) 如果 `XXX:YYY` 是您的BOT API 令牌。
10. 在 JSON 响应中，找到并复制 **聊天ID**。 在 **聊天** 和 **标题** 之间找到它。 _聊天ID_:  `-1123123123`

    ```text
    "聊天":{"id":-123123123,"title":
    ```

11. 将 **聊天ID** 粘贴到相应的字段 **Grafana** 中。
12. **保存并测试通知频道**。
13. 现在您可以从您的仪表板创建自定义提醒。 [前往这里学习如何创建警报。](https://grafana.com/docs/grafana/latest/alerting/create-alerts/)
{% endtab %}

{% tab title="Discord Notifications" %}
1. 在 Grafana 菜单中，在铃声图标下选择 **个通知频道**。
2. 点击 **添加频道**。
3. 在通知频道中添加 **名称**。
4. 从类型列表中选择 **Discord**。
5. 要完成设置，需要一个 Discord 服务器 \(和文本频道可用\) 和 Webhook URL。 For instructions on setting up a Discord's Webhooks, see [this section](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks) of their documentation.
6. 在 Discord 通知设置面板中输入 Webhook **URL**。
7. 点击 **发送测试**, 以便将确认消息推送到 Discord 频道。
{% endtab %}

{% tab title="Slack Notifications" %}
1. 在 Grafana 菜单中，在铃声图标下选择 **个通知频道**。
2. 点击 **添加频道**。
3. 在通知频道中添加 **名称**。
4. 从类型列表中选择 **Slack**。
5. 关于设置Slack传入Webhooks的指示，请参阅 [他们的文档](https://api.slack.com/messaging/webhooks) 部分。
6. 输入 **URL** 字段中的 Slack 传入的 Webhook URL。
7. 点击 **发送测试**, 以便将确认消息推送到 Slack 频道。
{% endtab %}
{% endtabs %}

### :water_wave：6.4 由 Google Cloud 使用 Uptime 检查

{% hint style="info" %}
谁关注看守者？ 使用外部第三方工具，如Uptime检查， 在发生诸如断电、硬件故障或互联网故障等灾害时，您可以有更大的放心来保证您的验证器正在运行。 在这些情况下，Prometheus和Grafana前面提到的监测也很可能停止运作。

感谢 [Mohamed Mansour激励我们指导](https://www.youtube.com/watch?v=txgOVDTemPQ)。
{% endhint %}

这是如何设置一个无费用的监测服务，由 Google命名为Uptime 检查。

{% hint style="info" %}
观看 [MohamedMansour的 eth2 教育视频](https://www.youtube.com/watch?v=txgOVDTemPQ)。 请支持他的 [GITCOIN 赠与](https://gitcoin.co/grants/1709/video-educational-grant)。 🙏
{% endhint %}

1. 访问 [cloud.google.com](https://cloud.google.com/)
2. 在搜索字段中搜索 **监视**。
3. 点击 **选择一个项目来开始监测**。
4. 点击 **新建项目。**
5. **命名** 您的项目，然后点击 **创建。**
6. 从通知菜单中选择新项目。
7. 右栏有一张监控卡。 点击 **前往监视**。
8. 在左侧菜单中，点击 **更新时间检查** 然后 **创建UPTIME查询**
9. 在标题中输入 _**地理节点**_
10. 选择协议为 _**TCP**_
11. 输入您的公共IP地址和端口号。 即ip=**7.55.6.3** 和 port=**30303**
12. 选择您所需的频率，即 **5 分钟。**
13. 选择距离您最近的区域进行检查。 单击下拉列表
14. 创建通知通道。 点击 **管理通知频道。**
15. 选择您想要的设置。 从任何或所有Slack、Webhook、电子邮件或短信中选择。
16. 返回创建运行时间检查窗口。
17. 在通知栏内，点击刷新按钮加载您的新通知频道。
18. 选择所需的通知。
19. 点击 **TEST** 来验证您的通知设置正确。
20. 点击 **创建** 来完成。

{% hint style="success" %}
🎉Congrats on setting your validator! 你很高兴继续使用 eth2.0 。

你觉得我们的指南有用吗？ 让我们知道一个小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小小，我们会不断更新它。

使用 [cointr.ee 找到我们的捐赠 ](https://cointr.ee/coincashew)个地址。 🙏

任何反馈和所有拉取请求都非常感激。 🌛

在 Discord 上挂起并与他人聊天 @

[https://discord.gg/w8Bx8W2HPW](https://discord.gg/w8Bx8W2HPW) :grinning_face_with_big_eyes：
{% endhint %}

## 🧙♂7. Update a ETH2 client

当新版本被剪切时，您将想要更新到最新的稳定版本。 下面展示了如何更新您的 eth2 信标链和验证器。

{% hint style="info" %}
在更新前总是查看 **git 日志与命令`git log`** 或 **发布笔记** 可能需要你们注意的变化。
{% endhint %}

选择您的 ETH2 客户端。

{% tabs %}
{% tab title="Lighthouse" %}
查看发行笔记并检查断开的更改/功能。

[https://github.com/sigp/lightthouse/releases](https://github.com/sigp/lighthouse/releases)

拉取最新的源并构建它。

```bash
cd $HOME/git/lightthouse
git 抓取--all && git 签出稳定 && git 拉取

```

通过检查新版本号来验证构建完成。

```bash
lightthouse --版本
```

按照正常操作程序重新启动信标链和验证器。

```text
sudo systemctl 重新加载或重新启动信标链验证器
```
{% endtab %}

{% tab title="Nimbus" %}
查看发行笔记并检查断开的更改/功能。

[https://github.com/status-im/nimbus-eth2/releases](https://github.com/status-im/nimbus-eth2/releases)

拉取最新的源并构建它。

```bash
cd $HOME/git/nimbus-eth2
git 拉取 && make update
make NIMFLAGS="-d:昆虫" nimbus_信标节点
```

通过检查新版本号来验证构建完成。

```bash
cd $HOME/git/nimbus-eth2/build
./nimbus_beacon_node --version
```

停止、复制新二进制并按照正常操作程序重启信标链和验证器。

```bash
sudo systemctl stop 信标-chain
sudo rm /usr/bin/nimbus_beacon_node
sudo cp $HOME/git/nimbus-eth2/build/nimbus_beacon_node /usr/bin
sudo systemctl reload-or rehon-chain
```
{% endtab %}

{% tab title="Teku" %}
查看发行笔记并检查断开的更改/功能。

[https://github.com/ConsenSys/teku/releases](https://github.com/ConsenSys/teku/releases)

拉取最新的源并构建它。

```bash
cd $HOME/git/teku
git 合并
./gradlew distt Tar installDist
```

通过检查新版本号来验证构建完成。

```bash
cd $HOME/git/teku/build/install/teku/bin
./teku --version
```

按照正常操作程序重新启动信标链和验证器。

```bash
sudo systemctl stop beacon-chain
sudo rm -rf /usr/bin/teku
sudo cp -r $HOME/git/teku/build/install/teku /usr/bin/teku
sudo systemctl reload-or-read-rehone chain
```
{% endtab %}

{% tab title="Prysm" %}
查看发行笔记并检查断开的更改/功能。 [https://github.com/prysmaticlabs/prysm/releases](https://github.com/prysmaticlabs/prysm/releases)

```bash
#只需重新启动进程
sudo systemctl 重新加载或重新启动信标链验证器
```
{% endtab %}

{% tab title="Lodestar" %}
查看发行笔记并检查断开的更改/功能。

[https://github.com/ChainSafe/lodestar/releases](https://github.com/ChainSafe/lodestar/releases)

拉取最新的源并构建它。

```bash
cd $HOME/git/logestar
git 拉取
yarn installing
yarn 运行 building
```

通过检查新版本号来验证构建完成。

```bash
yarn 运行 cli --version
```

按照正常操作程序重新启动信标链和验证器。

```text
sudo systemctl 重新加载或重新启动信标链验证器
```
{% endtab %}
{% endtabs %}

检查日志以验证服务正常工作，并确保没有错误。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl 状态信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl 状态信标
```
{% endtab %}
{% endtabs %}

## 🔥8. 其他有用的提示

### 🛑 8.1 自愿退出验证器

{% hint style="info" %}
使用此命令表示您打算停止与您的验证器验证。 这意味着您不再想要与您的验证器关联，想要关闭您的节点。

* 自愿退出至少需要 2048 epochs \(或~9days \)。 在您的验证程序最终退出之前，有一个要退出的队列和延迟。
* 一旦验证器在阶段0退出，这是不可逆转的，您无法重新开始验证。
* 您的资金将在1.5或更高阶段前无法提款。
* 在您的验证器离开出口队列并真正退出后，关闭您的信标节点和验证器是安全的。
{% endhint %}

{% tabs %}
{% tab title="Lighthouse" %}
```bash
lightthouse 帐户验证器退出
--keystore $HOME/.lightthouse/mainnet/validators \
--beacon-node http://localhost:5052
```
{% endtab %}

{% tab title="Teku" %}
```bash
teku voluntary-exk \
--epoch=<epoch number to exit> \
--beacon-node-api-endpoint=http://127.0.1:50:51
--validator-keys=<path to keystore.json>:<path to password.txt file>
```
{% endtab %}

{% tab title="Nimbus" %}
```bash
build/nimbus_beacon_node dosites ext --validator=<VALIDATOR_PUBLIC_KEY> --data-dir=/var/lib/nimbus
```
{% endtab %}

{% tab title="Prysm" %}
```bash
$HOME/prysm/prysm.sh 验证帐户自愿退出
```
{% endtab %}

{% tab title="Lodestar" %}
```bash
#待办事项
```
{% endtab %}
{% endtabs %}

### :old_key ︰ 8.2 验证您的 mnemonic

使用 eth2seosit-cli 工具来恢复您的 `validator_key` 以确保您可以重新生成相同的 eth2 键对。

```bash
cd $HOME/eth2存款-cli 
./depositing.sh existing-mnemonic --chain mainnet
```

{% hint style="info" %}
When the **pubkey** in both **keystore files** are **identical,** this means your mnemonic phrase is veritably correct. 其他字段因为打折而不同。
{% endhint %}

### 🤖8.3 添加额外的验证器

使用 eth2dosit-cli 工具，您可以通过创建新的存款数据文件和 `validator_keys` 来添加更多的验证器

首先，备份并移动您现有的 `validator_key` 目录并将日期附加到末尾。

```bash
cd $HOME/eth2存款-cli
mv validator_key validator_key_$(日期+"%Y%d%m-%H%M%S")
```

例如，如果我们最初创建了3个验证器，但现在希望添加5个验证器，我们可以使用以下命令。

```bash
cd $HOME/eth2存款-cli
./depositing.sh existing-mnemonic --validator_start_index 3 --num_validators 5 --chain mainnet
```

完成上传 `deposit_data-#########.json` 到发射台站并使您相应的 32 ETH 存款交易。

停止您的验证程序，导入新的验证键\(s\)，重新启动您的验证器并验证日志以确保所有仍然能够正常工作，从而完成验证程序。

### :money_with_wations: 8.4 开关/迁移Eth2 客户端，带有斜杠保护

{% hint style="info" %}
这一进程的关键是避免同时运行两个乙型客户端。 你想要避免受到减刑惩罚，因为减刑会导致失去食物。
{% endhint %}

#### 🛑 8.4.1 停止旧信标链和旧验证器。

为了导出折叠数据库，验证程序需要停止。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl stop 信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl stop 信标-chain
```
{% endtab %}
{% endtabs %}

#### :coly_disk: 8.4.2 导出斜杠数据库 \(可选\)

{% hint style="info" %}
[EIP-3076](https://eips.ethereum.org/EIPS/eip-3076) 实现了一个 eth2 客户端之间安全迁移验证器密钥的标准。 这是切换数据库中导出的内容。
{% endhint %}

更新导出.json文件位置和名称。

{% tabs %}
{% tab title="Lighthouse" %}
```bash
lightthouse 帐户验证器sashing-protection 导出 <lighthouse_interchange.json>
```
{% endtab %}

{% tab title="Nimbus" %}
待执行
{% endtab %}

{% tab title="Teku" %}
```bash
teku slashing-protection 导出 --to=<FILE>
```
{% endtab %}

{% tab title="Prysm" %}
待执行
{% endtab %}

{% tab title="Lodestar" %}
待执行
{% endtab %}
{% endtabs %}

#### :struction: 8.4.3 安装并安装新的验证器 / 信标链。

现在您需要设置/安装您的新验证器 **但不要开始运行 systemd 进程**。 请务必彻底关注您的新验证程序  [第4节。 配置一个 ETH2 信标链和验证器。](guide-or-how-to-setup-a-validator-on-eth2-testnet.md#4-configure-a-eth2-beacon-chain-node-and-validator) 您将需要构建/安装客户端，配置端口转发/防火墙，以及新的系统单元文件。

{% hint style="warning" %}
\*\*\*✨ **Pro Tip**: 在重新导入验证器密钥过程中, **等待至少13分钟** 或两分钟以防止减刑. 您必须避免同时运行具有相同验证密钥的两个eth2客户端。
{% endhint %}

{% hint style="danger" %}
🛑 **关键步骤**: 不要启动任意 **systemd 进程** 除非您有 **导入折叠数据库** 或您有 **等候至少13分钟或两分钟**
{% endhint %}

#### 📂 8.4.4 导入 slashing 数据库 \(可选\)

使用您的新的 eth2 客户端，运行以下命令并更新相关路径，以便在 2 步之前导入您的废止数据库。

{% tabs %}
{% tab title="Lighthouse" %}
```bash
lightthouse 帐户验证器sashing保护导入 <my_interchange.json>
```
{% endtab %}

{% tab title="Nimbus" %}
待执行
{% endtab %}

{% tab title="Teku" %}
```bash
teku slashing-protection importer --from=<FILE>
```
{% endtab %}

{% tab title="Prysm" %}
待执行
{% endtab %}

{% tab title="Lodestar" %}
待执行
{% endtab %}
{% endtabs %}

#### 🌠 8.4.5 启动新验证器和新信标链。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl启动信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl 启动信标链。
```
{% endtab %}
{% endtabs %}

#### 🔥 8.4.6 验证功能

检查日志以验证服务正常工作，并确保没有错误。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl 状态信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl 状态信标
```
{% endtab %}
{% endtabs %}

最后，验证你的验证器的注释正在与公共区块浏览器合作，例如：

[https://信标.in/](https://beaconcha.in/)

输入您的验证器的 pubkey 查看其状态。

#### :fire_extensions: 8.4.7 Update Monitoring with Prometheus and Grafana

[审阅第 6 节](guide-or-how-to-setup-a-validator-on-eth2-testnet.md#6-monitoring-your-validator-with-grafana-and-prometheus) 并更改您的 `promeus.yml` 确认 prometheus 已连接到您新的 eth2 客户端的计量端口。 您还想要导入您新的 eth2 客户端的仪表板。

### :desktop_compute: 8.5 使用所有可用的 LVM 磁盘空间

在 Ubuntu 服务器安装过程中，出现了一个常见问题，即您的硬盘空间无法完全使用。

```bash
# 查看您的磁盘驱动器
df

# 如果需要更改逻辑卷文件系统路径
lvextent -l +100%FREE /dev/ubuntu-vg/ubuntu-lv

退出
# 调整文件系统大小以使用逻辑卷中的新可用空间
调整大小为 /dev/ubuntu-vg/ubuntu-lv

#验证新可用空间
df -h
```

**源引用**:

{% 嵌入的 url="https://askubuntu.com/questions/1106795/ubuntu-server-18-04-lvm-out-space-with-imisper-default-partitioning" %}

### 🚦 8.6 减少网络带宽使用

{% hint style="info" %}
托管您自己的ETH1节点每天可以消耗数百千兆字节的数据。 由于数据计划可能有限或费用昂贵，您可能希望减慢数据使用速度，但仍然保持与网络的良好连接。
{% endhint %}

编辑您的 eth1.service Unit 文件。

```bash
sudo nano /etc/systemd/system/eth1.service
```

添加下面的标志来限制在 `ExecStart` 行上的友点数量。

{% tabs %}
{% tab title="Geth" %}
```bash
--maxpeers 10
# Example
# ExecStart       = /usr/bin/geth --maxpeers 10 --http --ws
```
{% endtab %}

{% tab title="OpenEtherum\(parity\)" %}
```bash
--max-peers 10
# Example
# ExecStart       = <home directory>/openethereum/openethereum --max-peers 10
```
{% endtab %}

{% tab title="Besu" %}
```bash
--max-peers 10
# 示例
# ExecStart = <home directory>/besu/besu --max-peers 10 --rpc-http-启用
```
{% endtab %}

{% tab title="Nethermind" %}
```bash
--ActivePeersMaxCount 10
# Example
# ExecStart       = <home directory>/nethermind/Nethermind.Runner --ActivePeersMaxCount 10 --JsonRpc.Enabled true
```
{% endtab %}
{% endtabs %}

最后，重新加载新的单元文件并重启eth1节点。

```bash
sudo systemctl daemon-reload
sudo systemctl 重启 eth1
```

### 📂 8.7 重要的目录位置

{% hint style="info" %}
如果您需要找到您的验证器密钥、数据库目录或其他重要文件。
{% endhint %}

#### Eth2 客户端文件和位置

{% tabs %}
{% tab title="Lighthouse" %}
```bash
# 验证器密钥
~/.lightthouse/mainnet/validators

# 信标链数据
~/.lightthouse/mainnet/信标

# 所有验证器和密码的列表
~/. ightthouse/mainnet/validators/validator_definitions.yml

#Slash protection db
~/.lightthouse/mainnet/validators/slash_protection.sqlite
```
{% endtab %}

{% tab title="Nimbus" %}
```bash
# 验证器密钥
/var/lib/nimbus/validators

# 信标链数据
/var/lib/nimbus/db

#Slash protection db
/var/lib/nimbus/validators/slashing_protection.sqlite3

#Logs
/var/lib/nimbus/beacon.log
```
{% endtab %}

{% tab title="Teku" %}
```bash
# 验证器密钥
/var/lib/teku

# 信标链数据
~/tekudata/信标

#Slash protection db
~/tekudata/validator/slashprotection
```
{% endtab %}

{% tab title="Prysm" %}
```bash
# 验证器密钥
~/.eth2validators/prysm-wallet/v2/direct

# 信标链数据
~/.eth2/信标chaindata
```
{% endtab %}

{% tab title="Lodestar" %}
待办事项
{% endtab %}
{% endtabs %}

#### Eth1 节点文件和位置

{% tabs %}
{% tab title="Geth" %}
```bash
# 数据库位置
$HOME/.eysum
```
{% endtab %}

{% tab title="OpenEtherum\(parity\)" %}
```bash
# 数据库位置
$HOME/.local/share/openeythum
```
{% endtab %}

{% tab title="Besu" %}
```bash
# 数据库位置
$HOME/.besu/数据库
```
{% endtab %}

{% tab title="Nethermind" %}
```bash
#数据库位置
$HOME/.nethermind/nethermind_db/mainnet
```
{% endtab %}
{% endtabs %}

### 🌏 8.8 在另一台机器上托管ETH1 节点

{% hint style="info" %}
将你自己的ETH1节点托管在不同于你信标链和验证器居住的地方的机器上，可以允许一些额外的模块化和灵活性。
{% endhint %}

在 eth1 节点机器上，编辑您的 eth1.Service 设备文件。

```bash
sudo nano /etc/systemd/system/eth1.service
```

在 `ExecStart` 行上添加以下标志以允许远程传入的 http 或websocket api 请求。

{% hint style="info" %}
如果不使用 websockets，则无需包含ws 参数。 只有Nimbus需要websockets。
{% endhint %}

{% tabs %}
{% tab title="Geth" %}
```bash
--http.addr 0.0.0.0 --ws.addr 0.0.0.0
# Example
# ExecStart       = /usr/bin/geth --http.addr 0.0.0.0 --ws.addr 0.0.0.0 --http --ws
```
{% endtab %}

{% tab title="OpenEtherum\(parity\)" %}
```bash
--jsonrpc-interface=all --ws-interface=all
# 示例
# ExecStart = <home directory>/openetherum/openeyesum --jsonrpc-interface=all --ws-interface=all
```
{% endtab %}

{% tab title="Besu" %}
```bash
--rpc-http-host=0.0.0.0 --rpc-ws-enabled --rpc-ws-host=0.0.0.0
# Example
# ExecStart       = <home directory>/besu/bin/besu --rpc-http-host=0.0.0.0 --rpc-ws-enabled --rpc-ws-host=0.0.0.0 --rpc-http-enabled
```
{% endtab %}

{% tab title="Nethermind" %}
```bash
--JsonRpc.Host 0.0.0.0 --WebSockets启用
# 例
# ExecStart = <home directory>/nethermind/Nethermind.Runner --JsonRpc.Host 0.0.0.0 --WebSockets启用 --JsonRpc.Enabled --JsonRpc.Enable
```
{% endtab %}
{% endtabs %}

重新加载新的单元文件并重启eth1节点。

```bash
sudo systemctl daemon-reload
sudo systemctl 重启 eth1
```

在单独的托管信标链的机器上，更新信标链单元文件中的eth1节点的IP地址。

{% tabs %}
{% tab title="Lighthouse" %}
```bash
# 编辑信标链单元文件
nano /etc/system/beacon-chain.service
# 添加--eth1-endpoint 参数
# 示例
# --eth1-endpoint=http://192.168.10.22。
```
{% endtab %}

{% tab title="Nimbus" %}
```bash
# 编辑信标链单元文件
nano /etc/systemd/system/beacon-chain.service
# 修改--web-url 参数
# 示例
# --web3-url=ws://192.168.10.22
```
{% endtab %}

{% tab title="Teku" %}
```bash
# 编辑 teku.yaml
nano /etc/teku.yaml
# 更改eth1-endpoint
# 示例
# eth1-endpoint: "http://192.168.10.20:8545"
```
{% endtab %}

{% tab title="Prysm" %}
```bash
# 编辑信标链单元文件
nano /etc/systemd/system/beacon-chain.service
# 添加--http-web3provider 参数
# 示例
# --http-web3provider=http://192.168.10.20:8545
```
{% endtab %}

{% tab title="Lodestar" %}
```
tbd。
```
{% endtab %}
{% endtabs %}

重新加载更新的设备文件并重启信标链。

```bash
sudo systemctl daemon-reload
sudo systemctl 重启 信标链。
```

### 🎊 8.9 添加或更改 POAP 涂鸦标志

设置您的 `个图画`，一个包含在您的验证器块中的自定义消息，并且获得一个早期信标链验证器POAP 令牌。 [在这里提供 Ethereum 1.0 地址来生成您的 POAP 字符串](https://beaconcha.in/poap)

运行以下命令来设置 `MY_GRAFFITI` 变量。 在单引号之间替换 `<my POAP string or message>`

```bash
MY_GRAFFITI='<my POAP string or message>
# 示例
# MY_GRAFFFITI='poapAAAAAAACGatUA1bLuDnL4FMD13BfoD'
# MY_GRAFFFITI='eth2 rulz!'
```

{% hint style="info" %}
了解更多关于 [POAP - 出勤令牌证明。 ](https://www.poap.xyz/)
{% endhint %}

{% tabs %}
{% tab title="Lighthouse" %}
运行以下操作以重新创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标链。 ervice
After = network-online。 arget 

[Service]
用户 = $(whoami)
ExecStart = $(Lightthouse) vc --nets mainnet --graffiti "${MY_GRAFFITI}" 
重启 = 未完成

[Install]
WantedBy = 多用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```
{% endtab %}

{% tab title="Nimbus" %}
运行以下操作以重新创建一个 **单元文件** 来定义您的`信标链。服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/beacon-chain.service << EOF 
# The eth2 beacon chain service (part of systemd)
# file: /etc/systemd/system/beacon-chain.service 

[Unit]
Description     = eth2 beacon chain service
Wants           = network-online.target
After           = network-online.target 

[Service]
Type            = simple
User            = $(whoami)
WorkingDirectory= /var/lib/nimbus
Environment     = "ClientIP=\$(curl -s ident.me)"
ExecStart       = /bin/bash -c '/usr/bin/nimbus_beacon_node --network=mainnet --graffiti="${MY_GRAFFITI}" --data-dir=/var/lib/nimbus --nat=extip:\${ClientIP} --web3-url=ws://127.0.0.1:8546 --metrics --metrics-port=8008 --rpc --rpc-port=9091 --validators-dir=/var/lib/nimbus/validators --secrets-dir=/var/lib/nimbus/secrets --log-file=/var/lib/nimbus/beacon.log --max-peers=100'
Restart         = on-failure

[Install]
WantedBy    = multi-user.target
EOF
```

{% hint style="warning" %}
Nimbus只支持 ETH1 节点的 websocket 连接\("ws://" 和 "wss://"\")。 Geth, OpenEthereum 和 Infura ETH1 节点是验证兼容的。
{% endhint %}

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/信标-chain.service /etc/system/system/beacon-chain.service
```

更新文件权限。

```bash
sudo chmod 644 /etc/system/system/beacon-chain.service
```
{% endtab %}

{% tab title="Teku" %}
重新生成您的 Teku 配置文件。 只复制和粘贴。

```bash
cat > $HOME/teku.yaml << EOF
# network
network: "mainnet"

# p2p
p2p-enabled: true
p2p-port: 9000
# validators
validator-keys: "/var/lib/teku/validator_keys:/var/lib/teku/validator_keys"
validators-graffiti: "${MY_GRAFFITI}"

# Eth 1
eth1-endpoint: "http://localhost:8545"

# metrics
metrics-enabled: true
metrics-categories: ["BEACON","LIBP2P","NETWORK"]
metrics-port: 8008

# database
data-path: "$(echo $HOME)/tekudata"
data-storage-mode: "archive"

# rest api
rest-api-port: 5051
rest-api-docs-enabled: true
rest-api-enabled: true

# logging
log-include-validator-duties-enabled: true
log-destination: CONSOLE
EOF
```

移动配置文件到 `/etc/teku`

```bash
sudo mv $HOME/teku.yaml /etc/teku/teku.yaml
```
{% endtab %}

{% tab title="Prysm" %}
重新创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标-chain.service
After = network-online。 arget 

[Service]
用户 = $(whoami)
ExecStart = $(echo $HOME)/prysm/prysm。 h validator --mainnet --graffiti "${MY_GRAFFITI}" --accept-terms of use --wallet-password-file $(echo $HOME)/. th2validators/validators-password xt
重启 = 发生故障

[Install]
WantedBy = 多用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

 更新其权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```
{% endtab %}

{% tab title="Lodestar" %}
运行以下操作以重新创建一个 **单元文件** 来定义您的`验证服务` 配置。 只复制和粘贴。

```bash
cat > $HOME/validator。 ervice << EOF 
# eth2 validator service (part of system)
# 文件：/etc/systemd/system/validator。 ervice 

[Unit]
描述 = eth2 validator 服务
Wants = 网络在线。 arget 信标-chain.service
After = network-online。 arget 

[Service]
用户 = $(whoami)
WorkingDirectory= $(echo $HOME)/git/lodestar
ExecStart = yarn run cli validator run --network mainnet --graffiti "${MY_GRAFFITI}"
Restart = 发生故障

[Install]
WantedBy = multi用户。 arget
EOF
```

移动单位文件到 `/etc/system/system/system`

```bash
sudo mv $HOME/validator.service /etc/systemd/system/validator.service
```

 更新其权限。

```bash
sudo chmod 644 /etc/systemd/system/validator.service
```
{% endtab %}
{% endtabs %}

重新加载更新的单位文件并重启验证程序以使您的图画生效。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl 守护进程重新加载
sudo systemctl 重启验证器
```
{% endtab %}

{% tab title="Teku \| Nimbus" %}
```
sudo systemctl daemon-reload
sudo systemctl 重启 信标链。
```
{% endtab %}
{% endtabs %}

### 📦 8.10 更新一个 ETH1 节点 - Geth / OpenEthereum / Besu / Netherlands

{% hint style="info" %}
不时更新最新的ETH1版本，以享受新的改进和功能。
{% endhint %}

停止您的 eth2 信标链、验证器和 eth1 节点流程。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
# 这可能需要一些时间。
sudo systemctl stop validator 信标链eth1
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```bash
# 这可能需要一些时间。
sudo systemctl stop 信标链eth1
```
{% endtab %}
{% endtabs %}

更新 eth1 节点包或二进制文件。

{% tabs %}
{% tab title="Geth" %}
在 [https://github.com/efecum/go-thereyum/releases](https://github.com/ethereum/go-ethereum/releases) 查看最新版本说明

```bash
sudo apt update 更新
sudo apt 升级 -y
```
{% endtab %}

{% tab title="OpenEtherum\(parity\)" %}
查看最新版本： [https://github.com/openetherum/openetherum/releases](https://github.com/openethereum/openethereum/releases)

自动下载最新的 linux 版本，un-zip，添加执行权限并清理。

```bash
cd $HOME
# 备份之前的 openeyum版本的回滚
mv openetherum_backup_$(日期+"%Y%d%m-%H%M%S")
# 在openethum 目录中存储新版本
mkdir openeyesum && cd openeneyum
# 下载最新版本
curl - s https://api。 ithub.com/repos/openef/openefum/releases/latest | jq -r ".assets[| select(.name) | browser_download_url" | grep linux | xargs wget -q --show-progress
# unzip
unzip openetherum*. ip
# 添加执行权限
chmod +x openeyum
# 清理
rm openetherum*.zip
```
{% endtab %}

{% tab title="Besu" %}
查看最新版本： [https://github.com/hyledger/besu/releases](https://github.com/hyperledger/besu/releases)

文件可以从 [https://dl.bintry.com/hyledger-org/besu-repo](https://dl.bintray.com/hyperledger-org/besu-repo) 下载。

手动从上方找到所需的文件并使用 URL 修改 `wget` 命令。

> 示例： 
> 
> wget -O besu.tar.gz [https://dl.bintry.com/hyledger-org/besu-repo/besu-20.10.1.tar.gz](https://dl.bintray.com/hyperledger-org/besu-repo/besu-20.10.1.tar.gz)

```bash
cd $HOME
# 备份以前的贝苏版本的回滚
mv besu besu_backup_$(date +"%Y%d%m-%H%M%S")
# 下载最新的besu
wget -O besu. ar.gz <https URL to latest tax.gz linux file>
# untar
tar -xvf besu.tar.gz
# 清理
rm besu. ar.gz
# 重命名besu 到标准文件夹位置
mv besu* besu
```
{% endtab %}

{% tab title="Nethermind" %}
查看最新版本： [https://github.com/NethermindEth/nethermind/releases](https://github.com/NethermindEth/nethermind/releases)

自动下载最新的 Linux 版本，un-zip 和清理。

```bash
cd $HOME
# 备份先前的下心灵版本的回滚
mv 下心恩的Netthermind_backup_$(日期+"%Y%d%m-%H%M%S")
# 将新版本存储在下心目录
mkdir 下心灵 && cd natherth 
# 下载最新版本
curl - s https://api。 ithub.com/repos/NethermindEth/nethermind/releases/latest | jq -r ".assets[] | select(.name) | rowser_download_url" | grep linux | xargs wget -q --show-progress
# unzip
unzip -o nethermind*.zip
# cleanup
rm nethermind*linux*.zip
```
{% endtab %}
{% endtabs %}

启动您的 eth2 信标链、验证器和 eth1 节点流程。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl start eth1 信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl start eth1 信标链启动
```
{% endtab %}
{% endtabs %}

检查日志以验证服务正常工作，并确保没有错误。

{% tabs %}
{% tabtabtitle="灯塔\| 胶囊\| 胶囊\| Lodestar" %}
```bash
sudo systemctl 状态乙1 状态信标链验证器
```
{% endtab %}

{% tab title="Nimbus \| Teku" %}
```
sudo systemctl 状态 eth1 信标-chain
```
{% endtab %}
{% endtabs %}

最后，验证你的验证器的注释正在与公共区块浏览器合作，例如：

[https://信标.in/](https://beaconcha.in/)

输入您的验证器的 pubkey 查看其状态。

## 🌇 9. 在 Discord 和 Reddit 上加入社区

### 📱 Discord

{% tabs %}
{% tab title="Lighthouse" %}
{% 嵌入的 url="https://discord.gg/cyAszAh" %}
{% endtab %}

{% tab title="Nimbus" %}
{% 嵌入的 url="https://discord.gg/XRxWahP" %}
{% endtab %}

{% tab title="Teku" %}
{% 嵌入的 url="https://discord.gg/7hPv2T6" %}
{% endtab %}

{% tab title="Prysm" %}
{% 嵌入的 url="https://discord.gg/XkyZSSk4My" %}
{% endtab %}

{% tab title="Lodestar" %}
{% 嵌入的 url="https://discord.gg/aMxzVcr" %}
{% endtab %}

{% tab title="CoinCashew" %}
{% 嵌入的 url="https://discord.gg/w8Bx8W2HPW" %}
{% endtab %}
{% endtabs %}

### :globe_showing_Europe-Africa：Reddit r/ethStaker

{% 嵌入的 url="https://www.reddit.com/r/ethstaker/" %}

## 🧩10. 参考材料

赞赏优秀民俗在以下链接所做的艰苦工作，以此作为编写本指南的基础。

{% 嵌入的 url="https://launchpad.efum.org/" %}

{% 嵌入的 url="https://pegasys.tech/teku-thero-2-for-enterprise/" %}

{% 嵌入的 url="https://docs.teku.pegasys.tech/enura/HowTo/Get-Started/Bur-From-Source/" %}

{% embed url="https://lightthouse-book.sigmaprime.io/intro.html" caption="" %}

{% embed url="https://status-im.github.io/nimbus-eth2/intro.html" %}

{% 嵌入的 url="https://prylabs.net/participate" %}

{% 嵌入的 url="https://docs.prylabs.network/docs/getting-started/" %}

{% 嵌入的 url="https://chainsafe.github.io/lodestar/installation/" %}

## 🎉11. 红包链接

### 🧱 ETH2 区块浏览器

{% 嵌入的 url="https://信标.in/" %}

{% 嵌入的 url="https://信标onscan.com/" 标题="" %}

### 🗒 最新Eth2 信息

{% 嵌入的 url="https://hackmd.io/@benjaminion/eth2\_news/" caption="" %}

{% embed url="https://www.reddit.com/r/ethstaker" caption="" %}

{% embed url="https://blog.efum.org/" caption="" %}

### 👨👩👧👦 Additional ETH2 Community Guides

{% 嵌入的 url="https://someresat.med.com/" %}

{% 嵌入的 url="https://github.com/metanull-operator/eth2-ubuntu" %}

{% embed url="https://agstakingco.gitbook.io/eth-2-0-staking-guide-medalla/" %}

#### 硬件Staking Guide [https://www.reddit.com/r/ethstaker/comments/j3mlup/a\_littly\_updated\_look\_hardware\_for\_staking/](https://www.reddit.com/r/ethstaker/comments/j3mlup/a_slightly_updated_look_at_hardware_for_staking/)

{% embed url="https://med.com/@RaymondDurk/how to stake-for-etherum-2-0-with-dappnode-231fa7689c0" %}

{% 嵌入的 url="https://kb.beaconcha.in/" %}



